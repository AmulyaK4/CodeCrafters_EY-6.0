// app.js (replace your current file)
import { renderChat, pushMessage, pushStructured } from "./components/chatbot.js";
import { renderDashboard, updateDashboard } from "./components/dashboard.js";

document.addEventListener("DOMContentLoaded", () => {
  // --- Config ---
  const HOSTNAME = window.location.hostname || "localhost";
  const apiBase = `${window.location.protocol}//${HOSTNAME}:8000`;
  const wsUrl = `ws://${HOSTNAME}:8000/ws/chat`;
  const chartDivId = "market-chart";
  const defaultUserId = "demo-user";

  // --- DOM nodes (guarded) ---
  const chatWindow = document.getElementById("chat-window");
  const input = document.getElementById("chat-input");
  const sendBtn = document.getElementById("send-btn");
  const dashboard = document.getElementById("dashboard-cards");

  if (dashboard) renderDashboard(dashboard);
  if (chatWindow) renderChat(chatWindow);

  // --- helpers ---
  const log = (msg, isErr = false) => {
    console[isErr ? "error" : "log"]("[app] " + msg);
    if (chatWindow) {
      // small visual feedback in chat window (non-invasive)
      // pushMessage(chatWindow, { from: "bot", text: msg }); // uncomment if you want chat logs
    }
  };

  // safe numeric coercion
  const toInt = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? Math.floor(n) : 0;
  };

  // --- WebSocket (resilient) ---
  let ws;
  let wsAttempts = 0;
  function connectWebSocket() {
    try {
      ws = new WebSocket(wsUrl);
      ws.onopen = () => {
        wsAttempts = 0;
        log("WebSocket connected");
      };
      ws.onmessage = (event) => {
        try {
          const payload = JSON.parse(event.data);
          if (payload?.data) {
            handleResponse(payload.data, payload.query_id ?? payload.data?.query_id ?? 0);
          } else {
            if (chatWindow) pushMessage(chatWindow, { from: "bot", text: event.data });
          }
        } catch (e) {
          if (chatWindow) pushMessage(chatWindow, { from: "bot", text: event.data });
        }
      };
      ws.onerror = (e) => {
        log("WebSocket error (check backend).", true);
      };
      ws.onclose = (ev) => {
        log(`WebSocket closed (code=${ev.code}). Reconnecting...`);
        wsAttempts = Math.min(wsAttempts + 1, 6);
        const backoff = Math.min(5000 * wsAttempts, 30000);
        setTimeout(connectWebSocket, backoff);
      };
      window.appWebSocket = ws;
    } catch (err) {
      log("WebSocket create failed: " + err, true);
      setTimeout(connectWebSocket, 3000);
    }
  }
  connectWebSocket();

  // --- sendQuery ---
  async function sendQuery() {
    const text = input?.value?.trim?.() ?? "";
    if (!text) {
      log("Enter a query first", true);
      return;
    }
    if (chatWindow) pushMessage(chatWindow, { from: "user", text });
    if (input) input.value = "";

    try {
      const resp = await fetch(`${apiBase}/api/chat`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_id: defaultUserId, query: text, context: {} }),
      });
      const json = await resp.json().catch(() => null);
      if (!resp.ok) {
        log("Chat POST failed: " + JSON.stringify(json || resp.status), true);
        if (chatWindow) pushMessage(chatWindow, { from: "bot", text: `Chat error: ${JSON.stringify(json)}` });
        return;
      }
      // extract data and query id from several shapes
      const data = json?.data ?? json;
      const qid = json?.query_id ?? data?.query_id ?? data?.id ?? 0;
      if (data) {
        handleResponse(data, toInt(qid));
      } else {
        pushMessage(chatWindow, { from: "bot", text: "No data returned from backend." });
      }
    } catch (err) {
      log("Chat request failed: " + err.message, true);
      if (chatWindow) pushMessage(chatWindow, { from: "bot", text: `Request failed: ${err.message}` });
    }
  }

  if (sendBtn) {
    sendBtn.addEventListener("click", (e) => {
      e.preventDefault();
      sendQuery();
    });
  } else {
    log("send-btn not found in DOM", true);
  }

  if (input) {
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") sendQuery();
    });
  }

  // --- PDF generation utility: ensure valid query_id ---
  async function ensureQueryId(originalQueryId, queryText) {
    const id = toInt(originalQueryId);
    if (id > 0) return id;

    // create a query via /api/chat to ensure there is a DB row to attach report to
    try {
      const resp = await fetch(`${apiBase}/api/chat`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_id: defaultUserId, query: queryText || "generated by frontend for PDF", context: {} }),
      });
      const json = await resp.json().catch(() => null);
      const data = json?.data ?? json;
      const newId = json?.query_id ?? data?.query_id ?? data?.id ?? 0;
      return toInt(newId);
    } catch (err) {
      log("Failed to create query for PDF: " + err.message, true);
      return 0;
    }
  }

  // call endpoint to generate PDF (returns URL or binary)
  async function requestPdf(payload) {
    const resp = await fetch(`${apiBase}/api/reports/pdf`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    const text = await resp.text().catch(() => "");
    if (!resp.ok) {
      // try to parse JSON error
      try {
        const j = JSON.parse(text || "{}");
        throw new Error(JSON.stringify(j));
      } catch (e) {
        throw new Error(text || `HTTP ${resp.status}`);
      }
    }
    // If JSON returned
    try {
      return JSON.parse(text || "{}");
    } catch (e) {
      // if binary (PDF) this won't run; handle in caller
      return { binaryText: text };
    }
  }

  // --- handleResponse (renders & attaches PDF button) ---
  function handleResponse(data, queryId) {
    const summaryText = data?.summary?.text ?? (typeof data === "string" ? data : data?.summary ?? "No summary available");
    if (chatWindow) pushStructured(chatWindow, summaryText);
    if (dashboard) updateDashboard(dashboard, data);

    if (data?.chart && window.Plotly) {
      try {
        const parsed = typeof data.chart === "string" ? JSON.parse(data.chart) : data.chart;
        Plotly.newPlot(chartDivId, parsed.data, parsed.layout || {});
      } catch (err) {
        console.warn("Plotly render failed:", err);
      }
    }

    // remove existing PDF button
    if (chatWindow) {
      const existing = chatWindow.querySelector(".pdf-generate-btn");
      if (existing) existing.remove();
    }

    // create PDF button
    const pdfBtn = document.createElement("button");
    pdfBtn.className = "pdf-generate-btn mt-3 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 cursor-pointer";
    pdfBtn.textContent = "ðŸ“„ Generate PDF Report";
    pdfBtn.style.marginTop = "12px";

    pdfBtn.onclick = async (ev) => {
      ev.preventDefault();
      pdfBtn.disabled = true;
      const prevText = pdfBtn.textContent;
      pdfBtn.textContent = "Generating...";

      try {
        // ensure valid query id (create query if missing)
        const qid = await ensureQueryId(queryId, data?.query_text ?? summaryText ?? "");
        if (!qid || qid <= 0) {
          throw new Error("Could not obtain a valid query_id for the report.");
        }

        const payload = {
          user_id: defaultUserId,
          query_id: qid,
          query: data?.query_text ?? summaryText ?? "no-query-text",
          summary_text: summaryText,
          format: "summary",
        };

        // request PDF
        const result = await requestPdf(payload);

        // if result has report_url, open it; otherwise if binary returned earlier, handle separately
        if (result?.report_url) {
          const downloadUrl = result.report_url.startsWith("http") ? result.report_url : `${apiBase}${result.report_url}`;
          window.open(downloadUrl, "_blank");
          pdfBtn.textContent = "âœ… PDF Generated - Click to download";
          pdfBtn.onclick = () => window.open(downloadUrl, "_blank");
          if (chatWindow) pushMessage(chatWindow, { from: "bot", text: `PDF ready: ${downloadUrl}` });
        } else if (result?.binaryText) {
          // backend returned binary but we parsed text; fetch as blob instead
          const blobResp = await fetch(`${apiBase}/api/reports/pdf`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const blob = await blobResp.blob();
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `report_${qid}.pdf`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          pdfBtn.textContent = "âœ… PDF downloaded";
          if (chatWindow) pushMessage(chatWindow, { from: "bot", text: `PDF downloaded for query ${qid}` });
        } else {
          throw new Error("Unexpected response from PDF endpoint: " + JSON.stringify(result));
        }
      } catch (err) {
        console.error("PDF generation error:", err);
        if (chatWindow) pushMessage(chatWindow, { from: "bot", text: `Error generating PDF: ${err.message}` });
        pdfBtn.textContent = "âŒ Error generating PDF";
        setTimeout(() => {
          pdfBtn.disabled = false;
          pdfBtn.textContent = prevText;
        }, 3000);
      }
    };

    // append and scroll
    if (chatWindow) {
      chatWindow.appendChild(pdfBtn);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }
  }

  // expose for debugging
  window.appSendQuery = sendQuery;
  window.appHandleResponse = handleResponse;
  log("App initialized (DOM ready).");
}); // DOMContentLoaded


